📌 Cursor AI 작업 지침서 (DB 분류 구조 재설계)
🎯 목표

기존의 대분류 / 중분류 / 소분류 테이블 구조를 전면 폐기하고,
확장 가능하고 중복 허용이 가능한 재귀형 분류 구조로 재설계한다.

대분류는 논리적으로 중복이 없으나

중분류 / 소분류는 이름 중복 가능

최종적으로는 경로(path) 또는 계층(depth)을 통해 유일성 확보

향후 중분류가 여러 단계로 확장될 수 있어야 함

❌ 제거 대상 (기존 구조)

아래 개념을 전제로 한 테이블은 모두 삭제한다.

대분류 테이블

중분류 테이블

소분류 테이블

대/중/소를 각각 FK로 연결한 구조

👉 이유

구조 확장 불가

중복 명칭 처리 불가

계층이 늘어나면 스키마 변경 필요

✅ 새로 설계할 테이블 (핵심)
1️⃣ 분류 테이블 (단일 테이블, 재귀 구조)
categories


역할

대분류 / 중분류 / 소분류를 모두 포함하는 통합 분류 테이블

자기 자신을 참조하는 재귀 구조

필수 컬럼

id (PK)

parent_id (nullable, FK → categories.id)

name (분류명, 중복 허용)

depth (0: 대분류, 1~N: 하위 분류)

path (예: /프로젝트/개발/백엔드)

sort_order (정렬용)

is_active

created_at

설계 포인트

parent_id IS NULL → 최상위 분류

depth는 계산 가능하지만 명시적으로 저장

path는 조회, 정렬, UI 구성 시 매우 중요

동일 name 허용, path로 구분

2️⃣ 작업(소분류에 해당하는 실제 작업) 테이블
tasks


역할

실제 업무, 작업, 아이템

“소분류”라는 개념을 테이블로 분리

필수 컬럼

id (PK)

category_id (FK → categories.id)

title

description

status

created_at

설계 이유

분류는 구조

작업은 데이터

역할을 명확히 분리

🔁 계층 조회 방식

다음 중 2가지를 함께 고려하여 설계

CTE 재귀 조회

부모 → 자식 트리 조회

자식 → 부모 경로 추적

path 기반 조회

특정 분류 하위 전체 조회

LIKE 또는 prefix 검색 가능

👉 둘 다 지원하도록 설계하는 것이 목표

📐 유일성 규칙

단일 컬럼 기준 유니크 ❌

아래 조합으로 논리적 유일성 확보 ⭕

(path)
또는
(parent_id + name)

🚀 확장 시나리오 (반드시 고려)

중분류가 2단 → 3단 → N단으로 늘어나는 경우

동일한 이름의 분류가 여러 경로에 존재

UI에서 트리 구조로 표현

특정 분류 하위의 모든 작업 조회

👉 스키마 변경 없이 대응 가능해야 함

🧩 산출물 요청

Cursor AI는 다음을 생성해야 한다.

✅ 기존 테이블 DROP SQL (safe-drop)

✅ 새로운 테이블 생성 SQL

✅ 인덱스 설계 (path, parent_id)

✅ 예시 데이터 INSERT

✅ 재귀 조회 예시 SQL (CTE)

✅ path 기반 조회 예시 SQL

⚠️ 주의사항

PostgreSQL 기준

하드코딩된 depth 제한 금지

ENUM 최소화

향후 API / UI 연계를 고려한 네이밍 사용